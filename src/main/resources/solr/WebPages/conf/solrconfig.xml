<?xml version="1.0" encoding="UTF-8" ?>
<config>
	<luceneMatchVersion>4.10.2</luceneMatchVersion>

  	<lib dir="../../../contrib/extraction/lib" regex=".*\.jar" />
  	<lib dir="../../../dist/" regex="apache-solr-cell-\d.*\.jar" />
  	<lib dir="../../../contrib/clustering/lib/" regex=".*\.jar" />
  	<lib dir="../../../dist/" regex="apache-solr-clustering-\d.*\.jar" />
  	<lib dir="../../../contrib/langid/lib/" regex=".*\.jar" />
  	<lib dir="../../../dist/" regex="apache-solr-langid-\d.*\.jar" />
  	<lib dir="../../../contrib/velocity/lib" regex=".*\.jar" />
  	<lib dir="../../../dist/" regex="apache-solr-velocity-\d.*\.jar" />
  
  	<lib dir="/total/crap/dir/ignored" /> 

  	<dataDir>${solr.data.dir:}</dataDir>

  	<directoryFactory name="DirectoryFactory" class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}"/> 

  	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       Index Config - These settings control low-level behavior of indexing
       Most example settings here show the default value, but are commented
       out, to more easily see where customizations have been made.
       
       Note: This replaces <indexDefaults> and <mainIndex> from older versions
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
  	<indexConfig>
    	<unlockOnStartup>true</unlockOnStartup>
  	</indexConfig>


	<!-- JMX   
       This example enables JMX if and only if an existing MBeanServer
       is found, use this if you want to configure JMX through JVM
       parameters. Remove this to disable exposing Solr configuration
       and statistics to JMX.
    -->
  	<jmx />

  	<!-- <jmx agentId="myAgent" /> -->
  	<!-- If you want to start a new MBeanServer, specify the serviceUrl -->
  	<!-- <jmx serviceUrl="service:jmx:rmi:///jndi/rmi://localhost:9999/solr"/>-->


  	<!-- The default high-performance update handler -->
  	<updateHandler class="solr.DirectUpdateHandler2">
     	<autoCommit> 
       		<maxTime>30000</maxTime> 
       		<openSearcher>true</openSearcher> 
     	</autoCommit>
       	<autoSoftCommit> 
        	<maxTime>10000</maxTime> 
       	</autoSoftCommit>
    	<updateLog>
      		<str name="dir">${solr.data.dir:}</str>
    	</updateLog>
  	</updateHandler>

  	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       Query section - these settings control query time things like caches
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
  	<query>
    	<!-- Max Boolean Clauses
         Maximum number of clauses in each BooleanQuery,  an exception
         is thrown if exceeded.
      	-->
    	<maxBooleanClauses>1024</maxBooleanClauses>
	
	    <filterCache class="solr.FastLRUCache"
	                 size="512"
	                 initialSize="512"
	                 autowarmCount="0"/>
	
	    <queryResultCache class="solr.LRUCache"
	                     size="512"
	                     initialSize="512"
	                     autowarmCount="0"/>
   
	    <documentCache class="solr.LRUCache"
	                   size="512"
	                   initialSize="512"
	                   autowarmCount="0"/>

    	<enableLazyFieldLoading>true</enableLazyFieldLoading>

   		<queryResultWindowSize>20</queryResultWindowSize>
   		<queryResultMaxDocsCached>200</queryResultMaxDocsCached>

    	<listener event="newSearcher" class="solr.QuerySenderListener">
      		<arr name="queries"> </arr>
    	</listener>
    	<listener event="firstSearcher" class="solr.QuerySenderListener">
      		<arr name="queries">
        		<lst>
          			<str name="q">static firstSearcher warming in solrconfig.xml</str>
        		</lst>
      		</arr>
    	</listener>

    	<useColdSearcher>false</useColdSearcher>
    	<maxWarmingSearchers>2</maxWarmingSearchers>

  	</query>

  	<requestDispatcher handleSelect="false" >
    	<requestParsers enableRemoteStreaming="true" multipartUploadLimitInKB="2048000" />
    	<httpCaching never304="true" />
 	 </requestDispatcher>

  	<requestHandler name="/select" class="solr.SearchHandler">
   
     	<lst name="defaults">
       		<str name="echoParams">explicit</str>
       		<int name="rows">10</int>
       		<str name="df">text</str>
     	</lst>
  	</requestHandler>

  	<!-- A request handler that returns indented JSON by default -->
  	<requestHandler name="/query" class="solr.SearchHandler">
     	<lst name="defaults">
       		<str name="echoParams">explicit</str>
       		<str name="wt">json</str>
       		<str name="indent">true</str>
       		<str name="df">text</str>
     	</lst>
  	</requestHandler>


  	<!-- realtime get handler, guaranteed to return the latest stored fields of
       any document, without the need to commit or open a new searcher.  The
       current implementation relies on the updateLog feature being enabled. -->
  	<requestHandler name="/get" class="solr.RealTimeGetHandler">
    	 <lst name="defaults">
       		<str name="omitHeader">true</str>
       		<str name="wt">json</str>
       		<str name="indent">true</str>
     	</lst>
  	</requestHandler>

  	<requestHandler name="/update" class="solr.UpdateRequestHandler">

  	</requestHandler>

  	<!-- for back compat with clients using /update/json and /update/csv -->  
  	<requestHandler name="/update/json" class="solr.JsonUpdateRequestHandler">
   		<lst name="defaults">
       		<str name="stream.contentType">application/json</str>
       	</lst>
  	</requestHandler>
  
  	<requestHandler name="/update/csv" class="solr.CSVRequestHandler">
        <lst name="defaults">
      		<str name="stream.contentType">application/csv</str>
       	</lst>
  	</requestHandler>

  	<requestHandler name="/update/extract" startup="lazy" class="solr.extraction.ExtractingRequestHandler" >
    	<lst name="defaults">
      		<str name="lowernames">true</str>
      		<str name="uprefix">ignored_</str>

      		<!-- capture link hrefs but ignore div attributes -->
      		<str name="captureAttr">true</str>
      		<str name="fmap.a">links</str>
      		<str name="fmap.div">ignored_</str>
    	</lst>
  	</requestHandler>

  	<requestHandler name="/analysis/field" 
                  startup="lazy"
                  class="solr.FieldAnalysisRequestHandler" />


  	<requestHandler name="/analysis/document" 
                  class="solr.DocumentAnalysisRequestHandler" 
                  startup="lazy" />


  	<requestHandler name="/admin/" 
                  class="solr.admin.AdminHandlers" />

  	<!-- ping/healthcheck -->
  	<requestHandler name="/admin/ping" class="solr.PingRequestHandler">
    	<lst name="invariants">
    	  <str name="q">solrpingquery</str>
   		</lst>
    	<lst name="defaults">
      		<str name="echoParams">all</str>
    	</lst>
  	</requestHandler>

  	<requestHandler name="/debug/dump" class="solr.DumpRequestHandler" >
    	<lst name="defaults">
    		<str name="echoParams">explicit</str> 
     		<str name="echoHandler">true</str>
    	</lst>
  	</requestHandler>
  
  	<requestHandler name="/replication" class="solr.ReplicationHandler" > 
    </requestHandler>

  	<searchComponent name="spellcheck" class="solr.SpellCheckComponent">
    	<str name="queryAnalyzerFieldType">textSpell</str>
   	 	<!-- a spellchecker built from a field of the main index -->
    	<lst name="spellchecker">
      		<str name="name">default</str>
      		<str name="field">name</str>
      		<str name="classname">solr.DirectSolrSpellChecker</str>
      		<!-- the spellcheck distance measure used, the default is the internal levenshtein -->
      		<str name="distanceMeasure">internal</str>
      		<!-- minimum accuracy needed to be considered a valid spellcheck suggestion -->
      		<float name="accuracy">0.5</float>
      		<!-- the maximum #edits we consider when enumerating terms: can be 1 or 2 -->
      		<int name="maxEdits">2</int>
      		<!-- the minimum shared prefix when enumerating terms -->
      		<int name="minPrefix">1</int>
		   	<!-- maximum number of inspections per result. -->
		  	<int name="maxInspections">5</int>
		   	<!-- minimum length of a query term to be considered for correction -->
		   	<int name="minQueryLength">4</int>
		   	<!-- maximum threshold of documents a query term can appear to be considered for correction -->
		   	<float name="maxQueryFrequency">0.01</float>
		   	<!-- uncomment this to require suggestions to occur in 1% of the documents
		      	<float name="thresholdTokenFrequency">.01</float>
		   	-->
    	</lst>
    
    	<!-- a spellchecker that can break or combine words.  See "/spell" handler below for usage -->
    	<lst name="spellchecker">
      		<str name="name">wordbreak</str>
      		<str name="classname">solr.WordBreakSolrSpellChecker</str>      
      		<str name="field">name</str>
      		<str name="combineWords">true</str>
      		<str name="breakWords">true</str>
      		<int name="maxChanges">10</int>
    	</lst>
  	</searchComponent>

 
  	<requestHandler name="/spell" class="solr.SearchHandler" startup="lazy">
		<lst name="defaults">
	    	<str name="df">text</str>
	      	<!-- Solr will use suggestions from both the 'default' spellchecker
	           and from the 'wordbreak' spellchecker and combine them.
	           collations (re-written queries) can include a combination of
	           corrections from both spellcheckers -->
	      	<str name="spellcheck.dictionary">default</str>
	      	<str name="spellcheck.dictionary">wordbreak</str>
	      	<str name="spellcheck">on</str>
	      	<str name="spellcheck.extendedResults">true</str>       
	      	<str name="spellcheck.count">10</str>
	      	<str name="spellcheck.alternativeTermCount">5</str>
	      	<str name="spellcheck.maxResultsForSuggest">5</str>       
	      	<str name="spellcheck.collate">true</str>
	      	<str name="spellcheck.collateExtendedResults">true</str>  
	      	<str name="spellcheck.maxCollationTries">10</str>
	      	<str name="spellcheck.maxCollations">5</str>         
	    </lst>
    	<arr name="last-components">
      		<str>spellcheck</str>
    	</arr>
  	</requestHandler>

  	<!-- Term Vector Component
       http://wiki.apache.org/solr/TermVectorComponent
    -->
  	<searchComponent name="tvComponent" class="solr.TermVectorComponent"/>
  	<requestHandler name="/tvrh" class="solr.SearchHandler" startup="lazy">
    	<lst name="defaults">
      		<str name="df">text</str>
      		<bool name="tv">true</bool>
    	</lst>
    	<arr name="last-components">
      		<str>tvComponent</str>
    	</arr>
  	</requestHandler>

  	<!-- Clustering Component
       http://wiki.apache.org/solr/ClusteringComponent
       You'll need to set the solr.cluster.enabled system property
       when running solr to run with clustering enabled:
            java -Dsolr.clustering.enabled=true -jar start.jar
    -->
  	<searchComponent name="clustering"
                   enable="${solr.clustering.enabled:false}"
                   class="solr.clustering.ClusteringComponent" >
    
    	<!-- Declare an engine -->
    	<lst name="engine">
      		<!-- The name, only one can be named "default" -->
      		<str name="name">default</str>

      		<!-- Class name of Carrot2 clustering algorithm.
           	* org.carrot2.clustering.lingo.LingoClusteringAlgorithm
           	* org.carrot2.clustering.stc.STCClusteringAlgorithm
           	* org.carrot2.clustering.kmeans.BisectingKMeansClusteringAlgorithm
        	-->
      		<str name="carrot.algorithm">org.carrot2.clustering.lingo.LingoClusteringAlgorithm</str>

      		<str name="LingoClusteringAlgorithm.desiredClusterCountBase">20</str>

      		<str name="carrot.lexicalResourcesDir">clustering/carrot2</str>

      		<!-- The language to assume for the documents. -->
      		<str name="MultilingualClustering.defaultLanguage">ENGLISH</str>
    	</lst>
    	<lst name="engine">
      		<str name="name">stc</str>
      		<str name="carrot.algorithm">org.carrot2.clustering.stc.STCClusteringAlgorithm</str>
    	</lst>
  	</searchComponent>

  	<!-- A request handler for demonstrating the clustering component
       This is purely as an example.
       	In reality you will likely want to add the component to your 
       	already specified request handlers. 
    	-->
  	<requestHandler name="/clustering"
                  startup="lazy"
                  enable="${solr.clustering.enabled:false}"
                  class="solr.SearchHandler">
                  
    	<lst name="defaults">
      		<bool name="clustering">true</bool>
      		<str name="clustering.engine">default</str>
      		<bool name="clustering.results">true</bool>
     		<!-- The title field -->
      		<str name="carrot.title">name</str>
      		<str name="carrot.url">id</str>
      		<!-- The field to cluster on -->
       		<str name="carrot.snippet">features</str>
       		<!-- produce summaries -->
       		<bool name="carrot.produceSummary">true</bool>
       		<!-- the maximum number of labels per cluster -->
       		<!--<int name="carrot.numDescriptions">5</int>-->
       		<!-- produce sub clusters -->
       		<bool name="carrot.outputSubClusters">false</bool>
       
       		<str name="defType">edismax</str>
       		<str name="qf">
         		text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0 manu^1.1 cat^1.4
       		</str>
       		<str name="q.alt">*:*</str>
       		<str name="rows">10</str>
       		<str name="fl">*,score</str>
    	</lst>     
    	<arr name="last-components">
      		<str>clustering</str>
    	</arr>
  	</requestHandler>
  
  	<!-- Terms Component
       http://wiki.apache.org/solr/TermsComponent
       A component to return terms and document frequency of those
       terms
    -->
  	<searchComponent name="terms" class="solr.TermsComponent"/>

  	<!-- A request handler for demonstrating the terms component -->
  	<requestHandler name="/terms" class="solr.SearchHandler" startup="lazy">
    	<lst name="defaults">
      		<bool name="terms">true</bool>
      		<bool name="distrib">false</bool>
    	</lst>     
    	<arr name="components">
      		<str>terms</str>
    	</arr>
  	</requestHandler>

  	<!-- Highlighting Component
       http://wiki.apache.org/solr/HighlightingParameters
    -->
  	<searchComponent class="solr.HighlightComponent" name="highlight">
    	<highlighting>
      		<!-- Configure the standard fragmenter -->
      		<!-- This could most likely be commented out in the "default" case -->
      		<fragmenter name="gap" 
                  default="true"
                  class="solr.highlight.GapFragmenter">
        		<lst name="defaults">
          			<int name="hl.fragsize">100</int>
        		</lst>
      		</fragmenter>

      		<!-- A regular-expression-based fragmenter 
           	(for sentence extraction) -->
      		<fragmenter name="regex" 
                  class="solr.highlight.RegexFragmenter">
        		<lst name="defaults">
          			<!-- slightly smaller fragsizes work better because of slop -->
          			<int name="hl.fragsize">70</int>
          			<!-- allow 50% slop on fragment sizes -->
          			<float name="hl.regex.slop">0.5</float>
          			<!-- a basic sentence pattern -->
          			<str name="hl.regex.pattern">[-\w ,/\n\&quot;&apos;]{20,200}</str>
        		</lst>
      		</fragmenter>

      		<!-- Configure the standard formatter -->
      		<formatter name="html" 
                 default="true"
                 class="solr.highlight.HtmlFormatter">
        		<lst name="defaults">
          			<str name="hl.simple.pre"><![CDATA[<em>]]></str>
          			<str name="hl.simple.post"><![CDATA[</em>]]></str>
        		</lst>
      		</formatter>

      		<!-- Configure the standard encoder -->
      		<encoder name="html" class="solr.highlight.HtmlEncoder" />

      		<!-- Configure the standard fragListBuilder -->
      		<fragListBuilder name="simple" class="solr.highlight.SimpleFragListBuilder"/>
      
      		<!-- Configure the single fragListBuilder -->
      		<fragListBuilder name="single" class="solr.highlight.SingleFragListBuilder"/>
      
      		<!-- Configure the weighted fragListBuilder -->
      		<fragListBuilder name="weighted" 
                       default="true"
                       class="solr.highlight.WeightedFragListBuilder"/>
      
      		<!-- default tag FragmentsBuilder -->
      		<fragmentsBuilder name="default" 
                        default="true"
                        class="solr.highlight.ScoreOrderFragmentsBuilder">
      		</fragmentsBuilder>

      		<!-- multi-colored tag FragmentsBuilder -->
      		<fragmentsBuilder name="colored" 
                        class="solr.highlight.ScoreOrderFragmentsBuilder">
        		<lst name="defaults">
          			<str name="hl.tag.pre"><![CDATA[
               			<b style="background:yellow">,<b style="background:lawgreen">,
               			<b style="background:aquamarine">,<b style="background:magenta">,
               			<b style="background:palegreen">,<b style="background:coral">,
               			<b style="background:wheat">,<b style="background:khaki">,
               			<b style="background:lime">,<b style="background:deepskyblue">]]></str>
          			<str name="hl.tag.post"><![CDATA[</b>]]></str>
        		</lst>
      		</fragmentsBuilder>
      
      		<boundaryScanner name="default" 
                       default="true"
                       class="solr.highlight.SimpleBoundaryScanner">
        		<lst name="defaults">
          			<str name="hl.bs.maxScan">10</str>
          			<str name="hl.bs.chars">.,!? &#9;&#10;&#13;</str>
        		</lst>
      		</boundaryScanner>
      
      		<boundaryScanner name="breakIterator" 
                       class="solr.highlight.BreakIteratorBoundaryScanner">
        		<lst name="defaults">
          			<!-- type should be one of CHARACTER, WORD(default), LINE and SENTENCE -->
          			<str name="hl.bs.type">WORD</str>
          			<!-- language and country are used when constructing Locale object.  -->
          			<!-- And the Locale object will be used when getting instance of BreakIterator -->
          			<str name="hl.bs.language">en</str>
          			<str name="hl.bs.country">US</str>
        		</lst>
      		</boundaryScanner>
    	</highlighting>
  	</searchComponent>
  
  	<!-- Language identification
       See more about langId at http://wiki.apache.org/solr/LanguageDetection
   	-->
   	<updateRequestProcessorChain name="langid">
   		<processor class="org.apache.solr.update.processor.TikaLanguageIdentifierUpdateProcessorFactory">
       		<str name="langid.fl">text,title,description</str>
       		<str name="langid.langField">language</str>
       		<str name="langid.fallback">en</str>
     	</processor>
      	<processor class="solr.LogUpdateProcessorFactory" />
      	<processor class="solr.RunUpdateProcessorFactory" />
  	</updateRequestProcessorChain>

  	<queryResponseWriter name="json" class="solr.JSONResponseWriter">
    	<str name="content-type">text/plain; charset=UTF-8</str>
  	</queryResponseWriter>
  
  	<!-- Custom response writers can be declared as needed... -->
    <queryResponseWriter name="velocity" class="solr.VelocityResponseWriter" startup="lazy"/>
  
  	<!-- XSLT response writer transforms the XML output by any xslt file found
       in Solr's conf/xslt directory.  Changes to xslt files are checked for
       every xsltCacheLifetimeSeconds.  
    -->
  	<queryResponseWriter name="xslt" class="solr.XSLTResponseWriter">
    	<int name="xsltCacheLifetimeSeconds">5</int>
  	</queryResponseWriter>

  	<!-- Legacy config for the admin interface -->
  	<admin>
    	<defaultQuery>*:*</defaultQuery>
  	</admin>

</config>